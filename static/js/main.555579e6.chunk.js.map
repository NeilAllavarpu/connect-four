{"version":3,"sources":["index.js"],"names":["Cell","props","react__WEBPACK_IMPORTED_MODULE_7___default","a","createElement","className","onClick","onMouseOut","onMouseOver","concat","classes","checkWinner","board","x1","y1","x2","y2","x3","y3","x4","y4","winner","length","highlightWinners","App","_this","Object","_Users_4E65696C_Documents_GitHub_connect_four_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__","this","_Users_4E65696C_Documents_GitHub_connect_four_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__","_Users_4E65696C_Documents_GitHub_connect_four_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__","call","state","color","Array","fill","x","_Users_4E65696C_Documents_GitHub_connect_four_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__","splice","y","results","offset","setState","status","_this2","i","row","_loop","j","push","key","handleClick","handleEnter","handleExit","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.555579e6.chunk.js","sourcesContent":["import \"./index.css\";\nimport React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\n\n/**\n * Mark a board's winning cells\n * @param {Array} board A 2-D array describing the board\n * @param {Number} x1 X-coordinate of the first winning cell\n * @param {Number} y1 Y-coordiante of the first winning cell\n * @param {Number} x2 X-coordinate of the second winning cell\n * @param {Number} y2 Y-coordiante of the second winning cell\n * @param {Number} x3 X-coordinate of the third winning cell\n * @param {Number} y3 Y-coordiante of the third winning cell\n * @param {Number} x4 X-coordinate of the fourth winning cell\n * @param {Number} y4 Y-coordiante of the fourth winning cell\n * @returns {Array} A 2-D array including the marked board\n */\nfunction highlightWinners(board, x1, y1, x2, y2, x3, y3, x4, y4) {\n    // update the first cell to have a win class\n    board[x1][y1] = `${board[x1][y1]} win`;\n    // update the second cell to have a win class\n    board[x2][y2] = `${board[x2][y2]} win`;\n    // update the third cell to have a win class\n    board[x3][y3] = `${board[x3][y3]} win`;\n    // update the fourth cell to have a win class\n    board[x4][y4] = `${board[x4][y4]} win`;\n    // return the updated board\n    return board;\n}\n\n/**\n * Renders a single cell on the board\n * @param {*} props Contains the current cell state, and onClick, onMouseOver, onMouseOut handlers\n * @returns {JSX} A JSX object for each cell in the board\n */\nfunction Cell(props) {\n    return (\n        // make this a cell, give it the passed onClick, onMouseOut, onMouseOver handlers\n        <button\n            className=\"cell\"\n            onClick={props.onClick}\n            onMouseOut={props.onMouseOut}\n            onMouseOver={props.onMouseOver}\n        >\n            {/* give the circle inside the cell the classes associated with it in the game board */}\n            <div className={`cell ${props.classes}`}></div>\n        </button>\n    );\n}\n\n/**\n * Check a series of cells for a potential match\n * @param {Array} board A 2-D array describing the board\n * @param {Number} x1 X-coordinate of the first cell to check\n * @param {Number} y1 Y-coordiante of the first cell to check\n * @param {Number} x2 X-coordinate of the second cell to check\n * @param {Number} y2 Y-coordiante of the second cell to check\n * @param {Number} x3 X-coordinate of the third cell to check\n * @param {Number} y3 Y-coordiante of the third cell to check\n * @param {Number} x4 X-coordinate of the fourth cell to check\n * @param {Number} y4 Y-coordiante of the fourth cell to check\n * @returns {Object} An object with a squares attribute with potentially marked squares (if the squares matched), and a winner attribute indicating if the squares matched\n */\nfunction checkWinner(board, x1, y1, x2, y2, x3, y3, x4, y4) {\n    // ensure that the first cell is defined\n    let winner = board[x1].length > y1 &&\n        // ensure that the second cell is defined\n        board[x2].length > y2 &&\n        // ensure that the third cell is defined\n        board[x3].length > y3 &&\n        // ensure that the fourth cell is defined\n        board[x4].length > y4 &&\n        // if the first cell matches the second cell\n        board[x1][y1] === board[x2][y2] &&\n        // if the first cell matches the third cell\n        board[x1][y1] === board[x3][y3] &&\n        // if the first cell matches the fourth cell\n        board[x1][y1] === board[x4][y4];\n    if (winner) {\n        // if we had a match, mark up the squares\n        board = highlightWinners(board, x1, y1, x2, y2, x3, y3, x4, y4);\n    }\n    // return the (potentially marked) squares and if we had a winner\n    return {board, winner};\n}\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n        // set the default conditions of the game\n        this.state = {\n            // Black gets to go first\n            \"color\": \"Black\",\n            // board is initially empty 2-D array\n            \"board\": Array(7).fill([]),\n            // no winner yet\n            \"winner\": null,\n        };\n    }\n\n    /**\n     * Handling for clicking on a cell\n     * @param {Number} x X-coordinate of the selected cell\n     */\n    handleClick(x) {\n        // get the current board, but don't modify it\n        let board = [...this.state.board];\n\n        // if we have the cell in a hover state\n        if (board[x][board[x].length - 1] === `possible${this.state.color}`) {\n            // remove the hover state cell\n            board[x].splice(board[x].length - 1, board[x].length);\n        }\n\n        // only if the current column isn't empty and we don't have a winner\n        if (board[x].length < 6 && this.state.winner === null) {\n            // add a cell of the current color to the board\n            board[x] = board[x].concat(this.state.color);\n            // y-coordinate of the selected cell would be the last element\n            const y = board[x].length - 1;\n            // variable to store the various results of the checkings\n            let results = {\n                // initially, board should be unchanged\n                \"board\": board,\n                // initially, we don't have a winner\n                \"winner\": false,\n            };\n            // make sure we can go down 3 cells from current cell (vertical check)\n            if (y >= 3) {\n                /**\n                 * Visualization of the check\n                 * x = current cell\n                 * * = other nodes we are checking\n                 * |x| | | |\n                 * |*| | | |\n                 * |*| | | |\n                 * |*| | | |\n                 */\n                // see if we have a winner vertically\n                results = checkWinner(board,\n                    // the selected cell\n                    x, y,\n                    // one below the selected cell\n                    x, y - 1,\n                    // two below the selected cell\n                    x, y - 2,\n                    // three below the selected cell\n                    x, y - 3);\n            }\n            // if we haven't already found a winner\n            if (results[\"winner\"] === false) {\n                // repeat 4 times, so that cell can be in each of the 4 possible positions for diagonal/horizontal matches\n                // note that the newly added cell will always be at the top of its column so it can only be in one position for a vertical match\n                for (let offset = 0; offset < 4; ++offset) {\n                    // for the rest of the loop the \"current cell\" will be the offset cell\n                    // i.e. (x + offset, y + offset)\n                    // unless its the third case, where it would be (x + offset, y - offset)\n\n                    // make sure that we can go at least 3 cells left, and we are not already off the right of the board (horizontal, diagonal checks)\n                    // also see if we haven't already found a winner\n                    if (x + offset >= 3 && x + offset < 7 && results[\"winner\"] === false) {\n                        /**\n                             * Visualization of the check\n                             * x = current cell\n                             * * = other nodes we are checking\n                             * | | | | |\n                             * | | | | |\n                             * | | | | |\n                             * |*|*|*|x|\n                             */\n                        // see if we have a winner horizontally\n                        results = checkWinner(board,\n                            // current cell\n                            x + offset, y,\n                            // 1 to the left of current cell\n                            x + offset - 1, y,\n                            // 2 to the left of current cell\n                            x + offset - 2, y,\n                            // 3 to the left of current cell\n                            x + offset - 3, y);\n                        // see if we haven't already found a winner\n                        // if so, make sure that current cell isn't above the board and we can go 3 below current cell (diagonal up + right check)\n                        if (results[\"winner\"] === false && y + offset < 6 && y + offset - 3 >= 0) {\n                            /**\n                             * Visualization of the check\n                             * x = current cell\n                             * * = other nodes we are checking\n                             * | | | |x|\n                             * | | |*| |\n                             * | |*| | |\n                             * |*| | | |\n                             */\n                            // see if we have a winner diagonally up + right\n                            results = checkWinner(board,\n                                // 3 left, 3 down from current cell\n                                x + offset - 3, y + offset - 3,\n                                // 2 left, 2 down from current cell\n                                x + offset - 2, y + offset - 2,\n                                // 1 left, 1 down from current cell\n                                x + offset - 1, y + offset - 1,\n                                // current cell\n                                x + offset, y + offset);\n                        }\n                        // see if we haven't already found a winner\n                        // here, current cell is (x + offset, y - offset)\n                        // make sure that current cell isn't below the board and we can go 3 above current cell (diagonal up + right check)\n                        if (results[\"winner\"] === false && y - offset + 3 < 6 && y - offset >= 0) {\n                            /**\n                             * Visualization of the check\n                             * x = current cell\n                             * * = other nodes we are checking\n                             * |*| | | |\n                             * | |*| | |\n                             * | | |*| |\n                             * | | | |x|\n                             */\n                            // see if we have a winner diagonally down + right\n                            results = checkWinner(board,\n                                // 3 left, 3 up from current cell\n                                x + offset - 3, y - offset + 3,\n                                // 2 left, 2 up from current cell\n                                x + offset - 2, y - offset + 2,\n                                // 1 left, 1 up from current cell\n                                x + offset - 1, y - offset + 1,\n                                // current cell\n                                x + offset, y - offset);\n                        }\n                    }\n                }\n            }\n\n            // if we found a winner\n            if (results[\"winner\"] === true) {\n                // winner! update the game to show this\n                this.setState({\n                    // update the board\n                    \"board\": results[\"board\"],\n                    // set the winner to the current color\n                    \"winner\": this.state.color,\n                });\n            } else {\n                // no winner, update the game status so\n                this.setState({\n                    // update the board\n                    \"board\": results[\"board\"],\n                    // switch between red and black\n                    \"color\": this.state.color === \"Black\" ? \"Red\" : \"Black\",\n                });\n            }\n        }\n    }\n\n    /**\n     * Handling for entering the mouse into a column\n     * @param {Number} x X-coordinate of the column\n     */\n    handleEnter(x) {\n        // make sure we don't show possibilities if game is over!\n        if (this.state.winner === null) {\n            // get the board, but make sure we don't modify it\n            let board = [...this.state.board];\n            // add a darker version of the current player's color to indicate a possible move\n            board[x] = board[x].concat(`possible${this.state.color}`);\n            this.setState({\n                // update the board with the dimmer circle\n                \"board\": board,\n            });\n        }\n    }\n\n    /**\n     * Handling for exiting the mouse from a column\n     * @param {Number} x X-coordinate of the column\n     */\n    handleExit(x) {\n        // get the board, but don't modify it\n        let board = [...this.state.board];\n        // if the column that the mouse left has a hover, darker circle at top of the column\n        if (board[x][board[x].length - 1] === `possible${this.state.color}`) {\n            // remove that hover, darker circle from the end of the column\n            board[x].splice(board[x].length - 1, board[x].length);\n            this.setState({\n                // update the board with the removed item\n                \"board\": board,\n            });\n        }\n    }\n\n    /**\n     * Main rendring of the whole screen\n     * @returns {JSX} A JSX element for the whole animation\n     */\n    render() {\n        // status that will be shown to the right of the board,\n        let status;\n        // if we have a winner\n        if (this.state.winner !== null) {\n            // status message is \"Winner: (winnerColor)\", where winnerColor is colored in its color\n            status = (\n                <div><span className=\"win-desc\">Winner: </span><span className={`${this.state.color}-text win-team`}>{this.state.color}</span></div>\n            );\n        } else {\n            // no winner yet\n            // status message is \"Next player: (nextPlayer)\", where nextPlayer is colored in its color\n            status = (\n                <div>Next player: <span className={`${this.state.color}-text`}>{this.state.color}</span></div>\n            );\n        }\n\n        // where our array of rows of cells will be stored (i.e. the board)\n        let board = [];\n        // for each of the rows\n        for (let i = 0; i < 6; ++i) {\n            // array to store the current row\n            let row = [];\n            // for each column\n            for (let j = 0; j < 7; ++j) {\n                // add a cell\n                // set its classes based on the current game's status\n                // set its click handler to facilitate the adding of chips and win checking, and pass it by column\n                // set its mouseOver and mouseOut handlers by the columns to handle hovering and the darker circle showing possibility\n                row.push(<Cell\n                    key={i * 7 + j}\n                    classes={this.state.board[j][5 - i]}\n                    onClick={() => this.handleClick(j)}\n                    onMouseOver={() => this.handleEnter(j)}\n                    onMouseOut={() => this.handleExit(j)}\n                />);\n            }\n            // add a row of our formed row to the board\n            board.push(\n                <div key={i} className=\"row\">\n                    {row}\n                </div>\n            );\n        }\n\n        return (\n            <div className=\"app\">\n                <div className=\"board\">{board}</div>{/* display the formed board */}\n                <div className=\"info\">{status}</div>{/* status display to the right of the board */}\n            </div>\n        );\n    }\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}